
\chapter{Przegląd literatury}\label{ch:review}

% TP: TODO: Ten rozdział powinien być przeglądem literatury na tematy związane z pracą. Sugeruję utworzyć sekcje poświęcone następującym tematom:
% W przeglądzie literatury powinniście porównać przeglądane prace z Waszą, w szczególności krótko napiszcie jakie są różnice, w czym Wasze podejście jest lepsze/inne. Im bardziej odległa tematycznie praca, tym to porównanie może być krótsze, albo nawet pominięte (np. przy odkrywaniu z przykładów rozwiązań) - chyba DONE

\section{Generowanie modeli \textit{PL} z opisów zagadnień optymalizacyjnych}
%\subsection*{\textit{OptiMUS}\cite{ahmaditeshnizi2023optimus}}
\label{sec:optimus}
% - Generowanie modeli PL z opisów zagadnień - alternatywne systemy działające na podobnej zasadzie -> OptiMUS
% Obecna sekcja "Podobne narzędzia - OptiMUS" może być zalążkiem dla Sekcji Generowanie modeli PL z opisów zagadnień, o której piszę wyżej. Trochę przerobiłem tekst, który tam jest. To musi być bardzo konkretnie napisane, bez nieistotnych informacji i lania wody.
\textit{OptiMUS} \cite{ahmaditeshnizi2023optimus} jest systemem opartym o \akronim{DMJ}, który generuje modele PL w języku Python, których kod jest zgodny z API solwerów takich jak Gurobi~\cite{gurobi2023}, na podstawie opisu słownego zagadnienia w języku angielskim.
OptiMUS, w przeciwieństwie do systemu opracowanego w ramach tej pracy dyplomowej, obsługuje modele \english{mixed-integer linear programming, MILP} i stosuje wiele iteracji w~celu identyfikacji i naprawy błędów w generowanych modelach.
OptiMUS, w przypadku wygenerowania niepoprawnego modelu lub błędnego kodu, ponawia zapytanie do \akronim{DMJ}, dołączając treść wygenerowanego błędu przez solver lub kod wynikowy. Dzięki temu system może iteracyjnie poprawiać model, identyfikując i eliminując błędy wynikające z niezgodności składni, braków w ograniczeniach lub innych problemów logicznych.
Program generuje wtedy poprawiony kod --- operacja jest wykonywana do momentu uzyskania poprawnej odpowiedzi, bądź do momentu osiągnięcia maksymalnej liczby iteracji.

\section{Odkrywanie modeli PL z innego rodzaju danych}
% - Odkrywanie modeli PL z innego rodzaju danych - metody/algorytmy syntezy/odkrywania/generowania modeli PL (i innych PM) na podstawie danych/przykładów/rozwiązań/informacji zwrotnej/uczenia aktywnego/itd.
%\subsection*{\akronim{GECS}
\akronim{GECS} (Grammatical Evolution for Constraint Synthesis)  \cite{pawlak2021grammatical} to algorytm syntezy ograniczeń dla \akronim{MILP} z przykładów rozwiązań dopuszczalnych i zbioru dostępnych zmiennych, parametrów i~zbiorów. GECS wykorzystuje gramatykę języka ZIMPL do tworzenia poprawnych składniowo modeli \akronim{MILP} w~języku \akronim{ZIMPL}. W~odróżnieniu od GECS, który wymaga dostarczenia szczegółowych danych wejściowych, takich jak zmienne i przykłady dopuszczalne, w~przedstawianym w niniejszej pracy systemie na wejściu wystarczający jest opis problemu PL zapisany w języku naturalnym, co eliminuje konieczność posiadania wiedzy eksperckiej do sformułowania problemu. Ponadto, system zaprezentowany w tej pracy jest bardziej przyjazny laikom, umożliwiając im tworzenie modeli PL bez konieczności głębokiego zrozumienia matematycznego sformułowania problemu.


\section{Duże modele językowe dla generowania kodu}
% - Duże modele językowe dla generowania kodu - w szczególności modele dedykowane pod generowanie modeli PL, np. AMPL ma taką nakładkę na ChatGPT https://ampl.com/guide-to-using-chatgpt-for-ampl-models-and-streamlit-apps/ Warto referować jakiś benchmark, który pozwoli wskazać, który model generalnie lepiej się sprawdza w szczególności modele dedykowane pod generowanie modeli PL, np. AMPL ma taką nakładkę na ChatGPT https://ampl.com/guide-to-using-chatgpt-for-ampl-models-and-streamlit-apps/ Warto referować jakiś benchmark, który pozwoli wskazać, który model generalnie lepiej się sprawdza
Niektóre implementacje \akronim{DMJ} takie jak \textit{ChatGPT} obecnie obsługują komercyjne języki modelowania, np.:~\akronim{AMPL} \cite{ampl_chatgpt_guide}. Wymaga to jednak posiadania licencji na ich użytkowanie. 
Przedstawione w niniejszej pracy rozwiązanie wykorzystuje język programowania \akronim{ZIMPL}, który jest darmowy i~otwartoźródłowy. Wybór \akronim{ZIMPL} pozwala uniknąć dodatkowych kosztów licencyjnych, jednocześnie umożliwiając budowę skalowalnych modeli optymalizacyjnych. Dzięki otwartemu kodowi źródłowemu, \akronim{ZIMPL} może być również, w razie potrzeby, dostosowany do konkretnych potrzeb projektowych co zwiększa jego elastyczność.







